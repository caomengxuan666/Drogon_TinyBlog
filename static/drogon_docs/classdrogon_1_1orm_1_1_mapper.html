<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drogon: drogon::orm::Mapper&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drogon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedrogon.html">drogon</a></li><li class="navelem"><b>orm</b></li><li class="navelem"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classdrogon_1_1orm_1_1_mapper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">drogon::orm::Mapper&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The mapper template.  
 <a href="classdrogon_1_1orm_1_1_mapper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_mapper_8h_source.html">Mapper.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a28df1a0dfde7017377d8223c629daccc" id="r_a28df1a0dfde7017377d8223c629daccc"><td class="memItemLeft" align="right" valign="top"><a id="a28df1a0dfde7017377d8223c629daccc" name="a28df1a0dfde7017377d8223c629daccc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SingleRowCallback</b> = std::function&lt; void(T)&gt;</td></tr>
<tr class="separator:a28df1a0dfde7017377d8223c629daccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1b164890a215eec80d37c7631f798f" id="r_a4a1b164890a215eec80d37c7631f798f"><td class="memItemLeft" align="right" valign="top"><a id="a4a1b164890a215eec80d37c7631f798f" name="a4a1b164890a215eec80d37c7631f798f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MultipleRowsCallback</b> = std::function&lt; void(std::vector&lt; T &gt;)&gt;</td></tr>
<tr class="separator:a4a1b164890a215eec80d37c7631f798f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d26f7c70e9b60bccdf98375719a30b" id="r_ab6d26f7c70e9b60bccdf98375719a30b"><td class="memItemLeft" align="right" valign="top"><a id="ab6d26f7c70e9b60bccdf98375719a30b" name="ab6d26f7c70e9b60bccdf98375719a30b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CountCallback</b> = std::function&lt; void(const size_t)&gt;</td></tr>
<tr class="separator:ab6d26f7c70e9b60bccdf98375719a30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9211b7091c112aecb52b88181cdeafb1" id="r_a9211b7091c112aecb52b88181cdeafb1"><td class="memItemLeft" align="right" valign="top"><a id="a9211b7091c112aecb52b88181cdeafb1" name="a9211b7091c112aecb52b88181cdeafb1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TraitsPKType</b> = typename <a class="el" href="structdrogon_1_1orm_1_1internal_1_1_traits.html">internal::Traits</a>&lt; T, !std::is_same_v&lt; typename T::PrimaryKeyType, void &gt; &gt;::type</td></tr>
<tr class="separator:a9211b7091c112aecb52b88181cdeafb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab768d38d626187a03c252d30d199ce02" id="r_ab768d38d626187a03c252d30d199ce02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#ab768d38d626187a03c252d30d199ce02">Mapper</a> (DbClientPtr client)</td></tr>
<tr class="memdesc:ab768d38d626187a03c252d30d199ce02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> object.  <br /></td></tr>
<tr class="separator:ab768d38d626187a03c252d30d199ce02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544796659f58a3e57c11d2eda991e390" id="r_a544796659f58a3e57c11d2eda991e390"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a544796659f58a3e57c11d2eda991e390">limit</a> (size_t limit)</td></tr>
<tr class="memdesc:a544796659f58a3e57c11d2eda991e390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a limit to the query.  <br /></td></tr>
<tr class="separator:a544796659f58a3e57c11d2eda991e390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c99d4587730c3fcd2cc7f53a1467235" id="r_a4c99d4587730c3fcd2cc7f53a1467235"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a4c99d4587730c3fcd2cc7f53a1467235">offset</a> (size_t offset)</td></tr>
<tr class="memdesc:a4c99d4587730c3fcd2cc7f53a1467235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a offset to the query.  <br /></td></tr>
<tr class="separator:a4c99d4587730c3fcd2cc7f53a1467235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795acb15aaf4d3aa2023daaa8496d988" id="r_a795acb15aaf4d3aa2023daaa8496d988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a795acb15aaf4d3aa2023daaa8496d988">orderBy</a> (const std::string &amp;colName, const SortOrder &amp;order=SortOrder::ASC)</td></tr>
<tr class="memdesc:a795acb15aaf4d3aa2023daaa8496d988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the order of the results.  <br /></td></tr>
<tr class="separator:a795acb15aaf4d3aa2023daaa8496d988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25ed6fb2a95a42260817a9572e0af13" id="r_af25ed6fb2a95a42260817a9572e0af13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#af25ed6fb2a95a42260817a9572e0af13">orderBy</a> (size_t colIndex, const SortOrder &amp;order=SortOrder::ASC)</td></tr>
<tr class="memdesc:af25ed6fb2a95a42260817a9572e0af13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the order of the results.  <br /></td></tr>
<tr class="separator:af25ed6fb2a95a42260817a9572e0af13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ffad65a6033ac542abe62385fdb2bd" id="r_a30ffad65a6033ac542abe62385fdb2bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a30ffad65a6033ac542abe62385fdb2bd">paginate</a> (size_t page, size_t perPage)</td></tr>
<tr class="memdesc:a30ffad65a6033ac542abe62385fdb2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set limit and offset to achieve pagination. This method will override <a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a544796659f58a3e57c11d2eda991e390" title="Add a limit to the query.">limit()</a> and <a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a4c99d4587730c3fcd2cc7f53a1467235" title="Add a offset to the query.">offset()</a>, and will be overridden by them.  <br /></td></tr>
<tr class="separator:a30ffad65a6033ac542abe62385fdb2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1cdcb5147dcdaabd905542a3a94502" id="r_acf1cdcb5147dcdaabd905542a3a94502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#acf1cdcb5147dcdaabd905542a3a94502">forUpdate</a> ()</td></tr>
<tr class="memdesc:acf1cdcb5147dcdaabd905542a3a94502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the result for updating.  <br /></td></tr>
<tr class="separator:acf1cdcb5147dcdaabd905542a3a94502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad044f425725b87f7849e967190eb8d0c" id="r_ad044f425725b87f7849e967190eb8d0c"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:ad044f425725b87f7849e967190eb8d0c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#ad044f425725b87f7849e967190eb8d0c">findByPrimaryKey</a> (const TraitsPKType &amp;key) noexcept(false)</td></tr>
<tr class="memdesc:ad044f425725b87f7849e967190eb8d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a record by the primary key.  <br /></td></tr>
<tr class="separator:ad044f425725b87f7849e967190eb8d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40599c84e4b422e05c996a28515040e1" id="r_a40599c84e4b422e05c996a28515040e1"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:a40599c84e4b422e05c996a28515040e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a40599c84e4b422e05c996a28515040e1">findByPrimaryKey</a> (const TraitsPKType &amp;key, const SingleRowCallback &amp;rcb, const ExceptionCallback &amp;ecb) noexcept</td></tr>
<tr class="memdesc:a40599c84e4b422e05c996a28515040e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously find a record by the primary key.  <br /></td></tr>
<tr class="separator:a40599c84e4b422e05c996a28515040e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47c5a512cfebd2d8215d02820f066f9" id="r_ac47c5a512cfebd2d8215d02820f066f9"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:ac47c5a512cfebd2d8215d02820f066f9"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#ac47c5a512cfebd2d8215d02820f066f9">findFutureByPrimaryKey</a> (const TraitsPKType &amp;key) noexcept</td></tr>
<tr class="memdesc:ac47c5a512cfebd2d8215d02820f066f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously find a record by the primary key.  <br /></td></tr>
<tr class="separator:ac47c5a512cfebd2d8215d02820f066f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357afbf24374e4809c6f2beca0a81be" id="r_a8357afbf24374e4809c6f2beca0a81be"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a8357afbf24374e4809c6f2beca0a81be">findAll</a> () noexcept(false)</td></tr>
<tr class="memdesc:a8357afbf24374e4809c6f2beca0a81be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the records in the table.  <br /></td></tr>
<tr class="separator:a8357afbf24374e4809c6f2beca0a81be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b22cca343c23c1256457605bbacc2fe" id="r_a1b22cca343c23c1256457605bbacc2fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a1b22cca343c23c1256457605bbacc2fe">findAll</a> (const MultipleRowsCallback &amp;rcb, const ExceptionCallback &amp;ecb) noexcept</td></tr>
<tr class="memdesc:a1b22cca343c23c1256457605bbacc2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously find all the records in the table.  <br /></td></tr>
<tr class="separator:a1b22cca343c23c1256457605bbacc2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fbd6006619deb7fdd8ccb1142c5599" id="r_a47fbd6006619deb7fdd8ccb1142c5599"><td class="memItemLeft" align="right" valign="top">std::future&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a47fbd6006619deb7fdd8ccb1142c5599">findFutureAll</a> () noexcept</td></tr>
<tr class="memdesc:a47fbd6006619deb7fdd8ccb1142c5599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously find all the records in the table.  <br /></td></tr>
<tr class="separator:a47fbd6006619deb7fdd8ccb1142c5599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a66d9cd558e9e2ae55fc0da578a7637" id="r_a8a66d9cd558e9e2ae55fc0da578a7637"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a8a66d9cd558e9e2ae55fc0da578a7637">count</a> (const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria=<a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a>()) noexcept(false)</td></tr>
<tr class="memdesc:a8a66d9cd558e9e2ae55fc0da578a7637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the count of rows that match the given criteria.  <br /></td></tr>
<tr class="separator:a8a66d9cd558e9e2ae55fc0da578a7637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3bad24eace8be9170eb95a49c7eb695" id="r_ae3bad24eace8be9170eb95a49c7eb695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#ae3bad24eace8be9170eb95a49c7eb695">count</a> (const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria, const CountCallback &amp;rcb, const ExceptionCallback &amp;ecb) noexcept</td></tr>
<tr class="memdesc:ae3bad24eace8be9170eb95a49c7eb695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously get the number of rows that match the given criteria.  <br /></td></tr>
<tr class="separator:ae3bad24eace8be9170eb95a49c7eb695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fb26af384e27f7dac6ea382f9485c9" id="r_ae0fb26af384e27f7dac6ea382f9485c9"><td class="memItemLeft" align="right" valign="top">std::future&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#ae0fb26af384e27f7dac6ea382f9485c9">countFuture</a> (const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria=<a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a>()) noexcept</td></tr>
<tr class="memdesc:ae0fb26af384e27f7dac6ea382f9485c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously get the number of rows that match the given criteria.  <br /></td></tr>
<tr class="separator:ae0fb26af384e27f7dac6ea382f9485c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687f0e49a850dc596beac1c84dc71b8a" id="r_a687f0e49a850dc596beac1c84dc71b8a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a687f0e49a850dc596beac1c84dc71b8a">findOne</a> (const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria) noexcept(false)</td></tr>
<tr class="memdesc:a687f0e49a850dc596beac1c84dc71b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find one record that matches the given criteria.  <br /></td></tr>
<tr class="separator:a687f0e49a850dc596beac1c84dc71b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecf88c448d89540c4d3583a410a888a" id="r_a2ecf88c448d89540c4d3583a410a888a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a2ecf88c448d89540c4d3583a410a888a">findOne</a> (const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria, const SingleRowCallback &amp;rcb, const ExceptionCallback &amp;ecb) noexcept</td></tr>
<tr class="memdesc:a2ecf88c448d89540c4d3583a410a888a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously find one record that matches the given criteria.  <br /></td></tr>
<tr class="separator:a2ecf88c448d89540c4d3583a410a888a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fc0ccf8e388d0c1f2dd8a1a3e2e1ce" id="r_a94fc0ccf8e388d0c1f2dd8a1a3e2e1ce"><td class="memItemLeft" align="right" valign="top">std::future&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a94fc0ccf8e388d0c1f2dd8a1a3e2e1ce">findFutureOne</a> (const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria) noexcept</td></tr>
<tr class="memdesc:a94fc0ccf8e388d0c1f2dd8a1a3e2e1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously find one record that matches the given criteria.  <br /></td></tr>
<tr class="separator:a94fc0ccf8e388d0c1f2dd8a1a3e2e1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042c203f4aea9bf6fe7fcf1f1e78e31f" id="r_a042c203f4aea9bf6fe7fcf1f1e78e31f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a042c203f4aea9bf6fe7fcf1f1e78e31f">findBy</a> (const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria) noexcept(false)</td></tr>
<tr class="memdesc:a042c203f4aea9bf6fe7fcf1f1e78e31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the rows that match the given criteria.  <br /></td></tr>
<tr class="separator:a042c203f4aea9bf6fe7fcf1f1e78e31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042fda8abb5f6a669f71886fe335c534" id="r_a042fda8abb5f6a669f71886fe335c534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a042fda8abb5f6a669f71886fe335c534">findBy</a> (const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria, const MultipleRowsCallback &amp;rcb, const ExceptionCallback &amp;ecb) noexcept</td></tr>
<tr class="memdesc:a042fda8abb5f6a669f71886fe335c534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously select the rows that match the given criteria.  <br /></td></tr>
<tr class="separator:a042fda8abb5f6a669f71886fe335c534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8804cea18195f5c5f1250af999f07e2b" id="r_a8804cea18195f5c5f1250af999f07e2b"><td class="memItemLeft" align="right" valign="top">std::future&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a8804cea18195f5c5f1250af999f07e2b">findFutureBy</a> (const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria) noexcept</td></tr>
<tr class="memdesc:a8804cea18195f5c5f1250af999f07e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously select the rows that match the given criteria.  <br /></td></tr>
<tr class="separator:a8804cea18195f5c5f1250af999f07e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1f913673dac9c1588379bea7ea82e2" id="r_acc1f913673dac9c1588379bea7ea82e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#acc1f913673dac9c1588379bea7ea82e2">insert</a> (T &amp;obj) noexcept(false)</td></tr>
<tr class="memdesc:acc1f913673dac9c1588379bea7ea82e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a row into the table.  <br /></td></tr>
<tr class="separator:acc1f913673dac9c1588379bea7ea82e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbf6f927e24ae0374c587e3a0b5cad9" id="r_a0bbf6f927e24ae0374c587e3a0b5cad9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a0bbf6f927e24ae0374c587e3a0b5cad9">insert</a> (const T &amp;obj, const SingleRowCallback &amp;rcb, const ExceptionCallback &amp;ecb) noexcept</td></tr>
<tr class="memdesc:a0bbf6f927e24ae0374c587e3a0b5cad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously insert a row into the table.  <br /></td></tr>
<tr class="separator:a0bbf6f927e24ae0374c587e3a0b5cad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5617f2634c50b0debe2f0ef6f0f9e4b" id="r_ae5617f2634c50b0debe2f0ef6f0f9e4b"><td class="memItemLeft" align="right" valign="top">std::future&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#ae5617f2634c50b0debe2f0ef6f0f9e4b">insertFuture</a> (const T &amp;) noexcept</td></tr>
<tr class="memdesc:ae5617f2634c50b0debe2f0ef6f0f9e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously insert a row into the table.  <br /></td></tr>
<tr class="separator:ae5617f2634c50b0debe2f0ef6f0f9e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac790a8de5878ad032c70a4df30a814db" id="r_ac790a8de5878ad032c70a4df30a814db"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#ac790a8de5878ad032c70a4df30a814db">update</a> (const T &amp;obj) noexcept(false)</td></tr>
<tr class="memdesc:ac790a8de5878ad032c70a4df30a814db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a record.  <br /></td></tr>
<tr class="separator:ac790a8de5878ad032c70a4df30a814db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7c8260a6d27b46fde938a46b8d80b2" id="r_aab7c8260a6d27b46fde938a46b8d80b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#aab7c8260a6d27b46fde938a46b8d80b2">update</a> (const T &amp;obj, const CountCallback &amp;rcb, const ExceptionCallback &amp;ecb) noexcept</td></tr>
<tr class="memdesc:aab7c8260a6d27b46fde938a46b8d80b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously update a record.  <br /></td></tr>
<tr class="separator:aab7c8260a6d27b46fde938a46b8d80b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9001de14c59a917e42c4a1bbb57a7b" id="r_a8f9001de14c59a917e42c4a1bbb57a7b"><td class="memItemLeft" align="right" valign="top">std::future&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a8f9001de14c59a917e42c4a1bbb57a7b">updateFuture</a> (const T &amp;obj) noexcept</td></tr>
<tr class="memdesc:a8f9001de14c59a917e42c4a1bbb57a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously update a record.  <br /></td></tr>
<tr class="separator:a8f9001de14c59a917e42c4a1bbb57a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4447263f366c14b4f2a22f3c386620f3" id="r_a4447263f366c14b4f2a22f3c386620f3"><td class="memTemplParams" colspan="2">template&lt;typename... Arguments&gt; </td></tr>
<tr class="memitem:a4447263f366c14b4f2a22f3c386620f3"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a4447263f366c14b4f2a22f3c386620f3">updateBy</a> (const std::vector&lt; std::string &gt; &amp;colNames, const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria, Arguments &amp;&amp;...args) noexcept(false)</td></tr>
<tr class="memdesc:a4447263f366c14b4f2a22f3c386620f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a record that match both the primary key and the given criteria.  <br /></td></tr>
<tr class="separator:a4447263f366c14b4f2a22f3c386620f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad91269d6ceb377cee126c2aafb7d03f" id="r_aad91269d6ceb377cee126c2aafb7d03f"><td class="memTemplParams" colspan="2">template&lt;typename... Arguments&gt; </td></tr>
<tr class="memitem:aad91269d6ceb377cee126c2aafb7d03f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#aad91269d6ceb377cee126c2aafb7d03f">updateBy</a> (const std::vector&lt; std::string &gt; &amp;colNames, const CountCallback &amp;rcb, const ExceptionCallback &amp;ecb, const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria, Arguments &amp;&amp;...args) noexcept</td></tr>
<tr class="memdesc:aad91269d6ceb377cee126c2aafb7d03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously select the rows that match both the primary key and the given criteria.  <br /></td></tr>
<tr class="separator:aad91269d6ceb377cee126c2aafb7d03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2d7d47e0903c8c84e2f9115be54e38" id="r_acb2d7d47e0903c8c84e2f9115be54e38"><td class="memTemplParams" colspan="2">template&lt;typename... Arguments&gt; </td></tr>
<tr class="memitem:acb2d7d47e0903c8c84e2f9115be54e38"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#acb2d7d47e0903c8c84e2f9115be54e38">updateFutureBy</a> (const std::vector&lt; std::string &gt; &amp;colNames, const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria, Arguments &amp;&amp;...args) noexcept</td></tr>
<tr class="memdesc:acb2d7d47e0903c8c84e2f9115be54e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously update a record that match both the primary key and the given criteria.  <br /></td></tr>
<tr class="separator:acb2d7d47e0903c8c84e2f9115be54e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef5041bc5c5beb57b5a109df325c2c2" id="r_aaef5041bc5c5beb57b5a109df325c2c2"><td class="memTemplParams" colspan="2">template&lt;typename... Arguments&gt; </td></tr>
<tr class="memitem:aaef5041bc5c5beb57b5a109df325c2c2"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#aaef5041bc5c5beb57b5a109df325c2c2">increment</a> (const std::vector&lt; std::string &gt; &amp;colNames, const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria, Arguments... args) noexcept(false)</td></tr>
<tr class="memdesc:aaef5041bc5c5beb57b5a109df325c2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update some records that match the given criteria.  <br /></td></tr>
<tr class="separator:aaef5041bc5c5beb57b5a109df325c2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3b1365474a612ad9e3a80b572d370c" id="r_a4b3b1365474a612ad9e3a80b572d370c"><td class="memTemplParams" colspan="2">template&lt;typename... Arguments&gt; </td></tr>
<tr class="memitem:a4b3b1365474a612ad9e3a80b572d370c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a4b3b1365474a612ad9e3a80b572d370c">increment</a> (const std::vector&lt; std::string &gt; &amp;colNames, const CountCallback &amp;rcb, const ExceptionCallback &amp;ecb, const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria, Arguments... args) noexcept</td></tr>
<tr class="memdesc:a4b3b1365474a612ad9e3a80b572d370c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously update some records that match the given criteria.  <br /></td></tr>
<tr class="separator:a4b3b1365474a612ad9e3a80b572d370c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706da16824423bc9bcafb3c7458af5c8" id="r_a706da16824423bc9bcafb3c7458af5c8"><td class="memTemplParams" colspan="2">template&lt;typename... Arguments&gt; </td></tr>
<tr class="memitem:a706da16824423bc9bcafb3c7458af5c8"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a706da16824423bc9bcafb3c7458af5c8">incrementFuture</a> (const std::vector&lt; std::string &gt; &amp;colNames, const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria, Arguments... args) noexcept</td></tr>
<tr class="memdesc:a706da16824423bc9bcafb3c7458af5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously update some records that match the given criteria.  <br /></td></tr>
<tr class="separator:a706da16824423bc9bcafb3c7458af5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722637648830ee076974397f36b10670" id="r_a722637648830ee076974397f36b10670"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a722637648830ee076974397f36b10670">deleteOne</a> (const T &amp;obj) noexcept(false)</td></tr>
<tr class="memdesc:a722637648830ee076974397f36b10670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a record from the table.  <br /></td></tr>
<tr class="separator:a722637648830ee076974397f36b10670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbee0e8d3c42bc59cad4518f4c08185" id="r_a6bbee0e8d3c42bc59cad4518f4c08185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a6bbee0e8d3c42bc59cad4518f4c08185">deleteOne</a> (const T &amp;obj, const CountCallback &amp;rcb, const ExceptionCallback &amp;ecb) noexcept</td></tr>
<tr class="memdesc:a6bbee0e8d3c42bc59cad4518f4c08185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously delete a record from the table.  <br /></td></tr>
<tr class="separator:a6bbee0e8d3c42bc59cad4518f4c08185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57426681ce435d4150c5e30d062d48b7" id="r_a57426681ce435d4150c5e30d062d48b7"><td class="memItemLeft" align="right" valign="top">std::future&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a57426681ce435d4150c5e30d062d48b7">deleteFutureOne</a> (const T &amp;obj) noexcept</td></tr>
<tr class="memdesc:a57426681ce435d4150c5e30d062d48b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously delete a record from the table.  <br /></td></tr>
<tr class="separator:a57426681ce435d4150c5e30d062d48b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461317af7297a633fa1d82162d864d93" id="r_a461317af7297a633fa1d82162d864d93"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a461317af7297a633fa1d82162d864d93">deleteBy</a> (const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria) noexcept(false)</td></tr>
<tr class="memdesc:a461317af7297a633fa1d82162d864d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete records that satisfy the given criteria.  <br /></td></tr>
<tr class="separator:a461317af7297a633fa1d82162d864d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3ee3170fe600325efb88abaa458882" id="r_aec3ee3170fe600325efb88abaa458882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#aec3ee3170fe600325efb88abaa458882">deleteBy</a> (const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria, const CountCallback &amp;rcb, const ExceptionCallback &amp;ecb) noexcept</td></tr>
<tr class="memdesc:aec3ee3170fe600325efb88abaa458882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete records that match the given criteria asynchronously.  <br /></td></tr>
<tr class="separator:aec3ee3170fe600325efb88abaa458882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033d0998221843611d3a761ab2f4764d" id="r_a033d0998221843611d3a761ab2f4764d"><td class="memItemLeft" align="right" valign="top">std::future&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a033d0998221843611d3a761ab2f4764d">deleteFutureBy</a> (const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;criteria) noexcept</td></tr>
<tr class="memdesc:a033d0998221843611d3a761ab2f4764d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete records that match the given criteria asynchronously.  <br /></td></tr>
<tr class="separator:a033d0998221843611d3a761ab2f4764d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8df86cc09e853e95266987c5a93184" id="r_a8c8df86cc09e853e95266987c5a93184"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a8c8df86cc09e853e95266987c5a93184">deleteByPrimaryKey</a> (const TraitsPKType &amp;key) noexcept(false)</td></tr>
<tr class="memdesc:a8c8df86cc09e853e95266987c5a93184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the record that matches the given primary key.  <br /></td></tr>
<tr class="separator:a8c8df86cc09e853e95266987c5a93184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b8ecf6709e151689c853da859e85fd" id="r_a13b8ecf6709e151689c853da859e85fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a13b8ecf6709e151689c853da859e85fd">deleteByPrimaryKey</a> (const TraitsPKType &amp;key, const CountCallback &amp;rcb, const ExceptionCallback &amp;ecb) noexcept</td></tr>
<tr class="memdesc:a13b8ecf6709e151689c853da859e85fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously delete the record that matches the given primary key.  <br /></td></tr>
<tr class="separator:a13b8ecf6709e151689c853da859e85fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7e944c38d770bd4050dd1d5d8716cf" id="r_adf7e944c38d770bd4050dd1d5d8716cf"><td class="memItemLeft" align="right" valign="top">std::future&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html#adf7e944c38d770bd4050dd1d5d8716cf">deleteFutureByPrimaryKey</a> (const TraitsPKType &amp;key) noexcept</td></tr>
<tr class="memdesc:adf7e944c38d770bd4050dd1d5d8716cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the record that matches the given primary key asynchronously.  <br /></td></tr>
<tr class="separator:adf7e944c38d770bd4050dd1d5d8716cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9b4b0d5831d350d4ad14a64580716f0b" id="r_a9b4b0d5831d350d4ad14a64580716f0b"><td class="memItemLeft" align="right" valign="top"><a id="a9b4b0d5831d350d4ad14a64580716f0b" name="a9b4b0d5831d350d4ad14a64580716f0b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a9b4b0d5831d350d4ad14a64580716f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bf551a2c396516e19b752c31302faf" id="r_a48bf551a2c396516e19b752c31302faf"><td class="memTemplParams" colspan="2"><a id="a48bf551a2c396516e19b752c31302faf" name="a48bf551a2c396516e19b752c31302faf"></a>
template&lt;typename PKType  = decltype(T::primaryKeyName)&gt; </td></tr>
<tr class="memitem:a48bf551a2c396516e19b752c31302faf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makePrimaryKeyCriteria</b> (std::string &amp;sql)</td></tr>
<tr class="separator:a48bf551a2c396516e19b752c31302faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96ee280eac4331d0f44251c4a934add" id="r_ae96ee280eac4331d0f44251c4a934add"><td class="memTemplParams" colspan="2"><a id="ae96ee280eac4331d0f44251c4a934add" name="ae96ee280eac4331d0f44251c4a934add"></a>
template&lt;typename PKType  = decltype(T::primaryKeyName)&gt; </td></tr>
<tr class="memitem:ae96ee280eac4331d0f44251c4a934add"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>outputPrimaryKeyToBinder</b> (const TraitsPKType &amp;pk, <a class="el" href="classdrogon_1_1orm_1_1internal_1_1_sql_binder.html">internal::SqlBinder</a> &amp;binder)</td></tr>
<tr class="separator:ae96ee280eac4331d0f44251c4a934add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8804bc2420c356ede3840cae2441a44e" id="r_a8804bc2420c356ede3840cae2441a44e"><td class="memTemplParams" colspan="2"><a id="a8804bc2420c356ede3840cae2441a44e" name="a8804bc2420c356ede3840cae2441a44e"></a>
template&lt;typename TP , ssize_t N = std::tuple_size&lt;TP&gt;::value&gt; </td></tr>
<tr class="memitem:a8804bc2420c356ede3840cae2441a44e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tupleToBinder</b> (const TP &amp;t, <a class="el" href="classdrogon_1_1orm_1_1internal_1_1_sql_binder.html">internal::SqlBinder</a> &amp;binder)</td></tr>
<tr class="separator:a8804bc2420c356ede3840cae2441a44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff29e08c1847c28978f78eace145a771" id="r_aff29e08c1847c28978f78eace145a771"><td class="memItemLeft" align="right" valign="top"><a id="aff29e08c1847c28978f78eace145a771" name="aff29e08c1847c28978f78eace145a771"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>replaceSqlPlaceHolder</b> (const std::string &amp;sqlStr, const std::string &amp;holderStr) const</td></tr>
<tr class="separator:aff29e08c1847c28978f78eace145a771"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac4500a57223978fa816eeba21aa0d353" id="r_ac4500a57223978fa816eeba21aa0d353"><td class="memItemLeft" align="right" valign="top"><a id="ac4500a57223978fa816eeba21aa0d353" name="ac4500a57223978fa816eeba21aa0d353"></a>
DbClientPtr&#160;</td><td class="memItemRight" valign="bottom"><b>client_</b></td></tr>
<tr class="separator:ac4500a57223978fa816eeba21aa0d353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c94a5ae853f2b3277d3970343d5d3e" id="r_a86c94a5ae853f2b3277d3970343d5d3e"><td class="memItemLeft" align="right" valign="top"><a id="a86c94a5ae853f2b3277d3970343d5d3e" name="a86c94a5ae853f2b3277d3970343d5d3e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>limit_</b> {0}</td></tr>
<tr class="separator:a86c94a5ae853f2b3277d3970343d5d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e8f625816bcb3c9fc3bfa0584fe76b" id="r_a88e8f625816bcb3c9fc3bfa0584fe76b"><td class="memItemLeft" align="right" valign="top"><a id="a88e8f625816bcb3c9fc3bfa0584fe76b" name="a88e8f625816bcb3c9fc3bfa0584fe76b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>offset_</b> {0}</td></tr>
<tr class="separator:a88e8f625816bcb3c9fc3bfa0584fe76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f10e9f45d6412e22bcc93b0ac34b6c" id="r_a14f10e9f45d6412e22bcc93b0ac34b6c"><td class="memItemLeft" align="right" valign="top"><a id="a14f10e9f45d6412e22bcc93b0ac34b6c" name="a14f10e9f45d6412e22bcc93b0ac34b6c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>orderByString_</b></td></tr>
<tr class="separator:a14f10e9f45d6412e22bcc93b0ac34b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ad49da080c99e40f5ab359e64e50e" id="r_a595ad49da080c99e40f5ab359e64e50e"><td class="memItemLeft" align="right" valign="top"><a id="a595ad49da080c99e40f5ab359e64e50e" name="a595ad49da080c99e40f5ab359e64e50e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>forUpdate_</b> {false}</td></tr>
<tr class="separator:a595ad49da080c99e40f5ab359e64e50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class drogon::orm::Mapper&lt; T &gt;</div><p>The mapper template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the model to be mapped.</td></tr>
  </table>
  </dd>
</dl>
<p>The mapping between the model object and the database table is performed by the <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> class template. The <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> class template encapsulates common operations such as adding, deleting, and changing, so that the user can perform the above operations without writing a SQL statement.</p>
<p>The construction of the <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> object is very simple. The template parameter is the type of the model you want to access. The constructor has only one parameter, which is the <a class="el" href="classdrogon_1_1orm_1_1_db_client.html" title="Database client abstract class.">DbClient</a> smart pointer mentioned earlier. As mentioned earlier, the <a class="el" href="classdrogon_1_1orm_1_1_transaction.html">Transaction</a> class is a subclass of <a class="el" href="classdrogon_1_1orm_1_1_db_client.html" title="Database client abstract class.">DbClient</a>, so you can also construct a <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> object with a smart pointer to a transaction, which means that the <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> mapping also supports transactions.</p>
<p>Like <a class="el" href="classdrogon_1_1orm_1_1_db_client.html" title="Database client abstract class.">DbClient</a>, <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> also provides asynchronous and synchronous interfaces. The synchronous interface is blocked and may throw an exception. The returned future object is blocked in the get() method and may throw an exception. The normal asynchronous interface does not throw an exception, but returns the result through two callbacks (result callback and exception callback). The type of the exception callback is the same as that in the <a class="el" href="classdrogon_1_1orm_1_1_db_client.html" title="Database client abstract class.">DbClient</a> interface. The result callback is also divided into several categories according to the interface function. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab768d38d626187a03c252d30d199ce02" name="ab768d38d626187a03c252d30d199ce02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab768d38d626187a03c252d30d199ce02">&#9670;&#160;</a></span>Mapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::Mapper </td>
          <td>(</td>
          <td class="paramtype">DbClientPtr&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The smart pointer to the database client object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae3bad24eace8be9170eb95a49c7eb695" name="ae3bad24eace8be9170eb95a49c7eb695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3bad24eace8be9170eb95a49c7eb695">&#9670;&#160;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountCallback &amp;&#160;</td>
          <td class="paramname"><em>rcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionCallback &amp;&#160;</td>
          <td class="paramname"><em>ecb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously get the number of rows that match the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
    <tr><td class="paramname">rcb</td><td>is clalled with the result. </td></tr>
    <tr><td class="paramname">ecb</td><td>is called when an error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a66d9cd558e9e2ae55fc0da578a7637" name="a8a66d9cd558e9e2ae55fc0da578a7637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a66d9cd558e9e2ae55fc0da578a7637">&#9670;&#160;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em> = <code><a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the count of rows that match the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of rows. </dd></dl>

</div>
</div>
<a id="ae0fb26af384e27f7dac6ea382f9485c9" name="ae0fb26af384e27f7dac6ea382f9485c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fb26af384e27f7dac6ea382f9485c9">&#9670;&#160;</a></span>countFuture()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; size_t &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::countFuture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em> = <code><a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously get the number of rows that match the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::future&lt;size_t&gt; The future object with which user can get the number of rows </dd></dl>

</div>
</div>
<a id="a461317af7297a633fa1d82162d864d93" name="a461317af7297a633fa1d82162d864d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461317af7297a633fa1d82162d864d93">&#9670;&#160;</a></span>deleteBy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::deleteBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete records that satisfy the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of deleted records. </dd></dl>

</div>
</div>
<a id="aec3ee3170fe600325efb88abaa458882" name="aec3ee3170fe600325efb88abaa458882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3ee3170fe600325efb88abaa458882">&#9670;&#160;</a></span>deleteBy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::deleteBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountCallback &amp;&#160;</td>
          <td class="paramname"><em>rcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionCallback &amp;&#160;</td>
          <td class="paramname"><em>ecb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete records that match the given criteria asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criteria</td><td>The criteria </td></tr>
    <tr><td class="paramname">rcb</td><td>is called with the number of deleted records. </td></tr>
    <tr><td class="paramname">ecb</td><td>is called when an error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c8df86cc09e853e95266987c5a93184" name="a8c8df86cc09e853e95266987c5a93184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8df86cc09e853e95266987c5a93184">&#9670;&#160;</a></span>deleteByPrimaryKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::deleteByPrimaryKey </td>
          <td>(</td>
          <td class="paramtype">const TraitsPKType &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the record that matches the given primary key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The primary key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of deleted records (1 or 0). </dd></dl>

</div>
</div>
<a id="a13b8ecf6709e151689c853da859e85fd" name="a13b8ecf6709e151689c853da859e85fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b8ecf6709e151689c853da859e85fd">&#9670;&#160;</a></span>deleteByPrimaryKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::deleteByPrimaryKey </td>
          <td>(</td>
          <td class="paramtype">const TraitsPKType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountCallback &amp;&#160;</td>
          <td class="paramname"><em>rcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionCallback &amp;&#160;</td>
          <td class="paramname"><em>ecb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously delete the record that matches the given primary key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The primary key. </td></tr>
    <tr><td class="paramname">rcb</td><td>is called with the number of deleted records. </td></tr>
    <tr><td class="paramname">ecb</td><td>is called when an error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a033d0998221843611d3a761ab2f4764d" name="a033d0998221843611d3a761ab2f4764d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033d0998221843611d3a761ab2f4764d">&#9670;&#160;</a></span>deleteFutureBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; size_t &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::deleteFutureBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete records that match the given criteria asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criteria</td><td>The criteria </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::future&lt;size_t&gt; The future object with which user can get the number of deleted records </dd></dl>

</div>
</div>
<a id="adf7e944c38d770bd4050dd1d5d8716cf" name="adf7e944c38d770bd4050dd1d5d8716cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7e944c38d770bd4050dd1d5d8716cf">&#9670;&#160;</a></span>deleteFutureByPrimaryKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; size_t &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::deleteFutureByPrimaryKey </td>
          <td>(</td>
          <td class="paramtype">const TraitsPKType &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the record that matches the given primary key asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The primary key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::future&lt;size_t&gt; The future object with which user can get the number of deleted records </dd></dl>

</div>
</div>
<a id="a57426681ce435d4150c5e30d062d48b7" name="a57426681ce435d4150c5e30d062d48b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57426681ce435d4150c5e30d062d48b7">&#9670;&#160;</a></span>deleteFutureOne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; size_t &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::deleteFutureOne </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously delete a record from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The record. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::future&lt;size_t&gt; The future object with which user can get the number of deleted records. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The table must have a primary key. </dd></dl>

</div>
</div>
<a id="a722637648830ee076974397f36b10670" name="a722637648830ee076974397f36b10670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722637648830ee076974397f36b10670">&#9670;&#160;</a></span>deleteOne() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::deleteOne </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a record from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The record. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of deleted records. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The table must have a primary key. </dd></dl>

</div>
</div>
<a id="a6bbee0e8d3c42bc59cad4518f4c08185" name="a6bbee0e8d3c42bc59cad4518f4c08185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbee0e8d3c42bc59cad4518f4c08185">&#9670;&#160;</a></span>deleteOne() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::deleteOne </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountCallback &amp;&#160;</td>
          <td class="paramname"><em>rcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionCallback &amp;&#160;</td>
          <td class="paramname"><em>ecb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously delete a record from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The record. </td></tr>
    <tr><td class="paramname">rcb</td><td>is called with the number of deleted records. </td></tr>
    <tr><td class="paramname">ecb</td><td>is called when an error occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The table must have a primary key. </dd></dl>

</div>
</div>
<a id="a8357afbf24374e4809c6f2beca0a81be" name="a8357afbf24374e4809c6f2beca0a81be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357afbf24374e4809c6f2beca0a81be">&#9670;&#160;</a></span>findAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::findAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the records in the table. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;T&gt; The vector of all the records. </dd></dl>

</div>
</div>
<a id="a1b22cca343c23c1256457605bbacc2fe" name="a1b22cca343c23c1256457605bbacc2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b22cca343c23c1256457605bbacc2fe">&#9670;&#160;</a></span>findAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::findAll </td>
          <td>(</td>
          <td class="paramtype">const MultipleRowsCallback &amp;&#160;</td>
          <td class="paramname"><em>rcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionCallback &amp;&#160;</td>
          <td class="paramname"><em>ecb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously find all the records in the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rcb</td><td>is called with the result. </td></tr>
    <tr><td class="paramname">ecb</td><td>is called when an error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a042c203f4aea9bf6fe7fcf1f1e78e31f" name="a042c203f4aea9bf6fe7fcf1f1e78e31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042c203f4aea9bf6fe7fcf1f1e78e31f">&#9670;&#160;</a></span>findBy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::findBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select the rows that match the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;T&gt; The vector of rows that match the given criteria. </dd></dl>

</div>
</div>
<a id="a042fda8abb5f6a669f71886fe335c534" name="a042fda8abb5f6a669f71886fe335c534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042fda8abb5f6a669f71886fe335c534">&#9670;&#160;</a></span>findBy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::findBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultipleRowsCallback &amp;&#160;</td>
          <td class="paramname"><em>rcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionCallback &amp;&#160;</td>
          <td class="paramname"><em>ecb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously select the rows that match the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
    <tr><td class="paramname">rcb</td><td>is called with the result. </td></tr>
    <tr><td class="paramname">ecb</td><td>is called when an error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad044f425725b87f7849e967190eb8d0c" name="ad044f425725b87f7849e967190eb8d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad044f425725b87f7849e967190eb8d0c">&#9670;&#160;</a></span>findByPrimaryKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::findByPrimaryKey </td>
          <td>(</td>
          <td class="paramtype">const TraitsPKType &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a record by the primary key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The value of the primary key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The record of the primary key. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If no hit record exists, an <a class="el" href="classdrogon_1_1orm_1_1_unexpected_rows.html" title="Query returned an unexpected number of rows.">UnexpectedRows</a> exception is thrown. </dd></dl>

</div>
</div>
<a id="a40599c84e4b422e05c996a28515040e1" name="a40599c84e4b422e05c996a28515040e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40599c84e4b422e05c996a28515040e1">&#9670;&#160;</a></span>findByPrimaryKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::findByPrimaryKey </td>
          <td>(</td>
          <td class="paramtype">const TraitsPKType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SingleRowCallback &amp;&#160;</td>
          <td class="paramname"><em>rcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionCallback &amp;&#160;</td>
          <td class="paramname"><em>ecb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously find a record by the primary key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The value of the primary key. </td></tr>
    <tr><td class="paramname">rcb</td><td>Is called when a record is found. </td></tr>
    <tr><td class="paramname">ecb</td><td>Is called when an error occurs or a record cannot be found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47fbd6006619deb7fdd8ccb1142c5599" name="a47fbd6006619deb7fdd8ccb1142c5599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fbd6006619deb7fdd8ccb1142c5599">&#9670;&#160;</a></span>findFutureAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; std::vector&lt; T &gt; &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::findFutureAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously find all the records in the table. </p>
<dl class="section return"><dt>Returns</dt><dd>std::future&lt;std::vector&lt;T&gt;&gt; The future object with which user can get the result. </dd></dl>

</div>
</div>
<a id="a8804cea18195f5c5f1250af999f07e2b" name="a8804cea18195f5c5f1250af999f07e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8804cea18195f5c5f1250af999f07e2b">&#9670;&#160;</a></span>findFutureBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; std::vector&lt; T &gt; &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::findFutureBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously select the rows that match the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::future&lt;std::vector&lt;T&gt;&gt; The future object with which user can get the result. </dd></dl>

</div>
</div>
<a id="ac47c5a512cfebd2d8215d02820f066f9" name="ac47c5a512cfebd2d8215d02820f066f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47c5a512cfebd2d8215d02820f066f9">&#9670;&#160;</a></span>findFutureByPrimaryKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; T &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::findFutureByPrimaryKey </td>
          <td>(</td>
          <td class="paramtype">const TraitsPKType &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously find a record by the primary key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The value of the primary key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::future&lt;T&gt; The future object with which user can get the result. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If no hit record exists, an <a class="el" href="classdrogon_1_1orm_1_1_unexpected_rows.html" title="Query returned an unexpected number of rows.">UnexpectedRows</a> exception is thrown when user calls the get() method of the future object. </dd></dl>

</div>
</div>
<a id="a94fc0ccf8e388d0c1f2dd8a1a3e2e1ce" name="a94fc0ccf8e388d0c1f2dd8a1a3e2e1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94fc0ccf8e388d0c1f2dd8a1a3e2e1ce">&#9670;&#160;</a></span>findFutureOne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; T &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::findFutureOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously find one record that matches the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::future&lt;T&gt; The future object with which user can get the result. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if the number of rows is greater than one or equal to zero, an <a class="el" href="classdrogon_1_1orm_1_1_unexpected_rows.html" title="Query returned an unexpected number of rows.">UnexpectedRows</a> exception is thrown when the get() method of the future object is called. </dd></dl>

</div>
</div>
<a id="a687f0e49a850dc596beac1c84dc71b8a" name="a687f0e49a850dc596beac1c84dc71b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687f0e49a850dc596beac1c84dc71b8a">&#9670;&#160;</a></span>findOne() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::findOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find one record that matches the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The result record. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if the number of rows is greater than one or equal to zero, an <a class="el" href="classdrogon_1_1orm_1_1_unexpected_rows.html" title="Query returned an unexpected number of rows.">UnexpectedRows</a> exception is thrown. </dd></dl>

</div>
</div>
<a id="a2ecf88c448d89540c4d3583a410a888a" name="a2ecf88c448d89540c4d3583a410a888a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ecf88c448d89540c4d3583a410a888a">&#9670;&#160;</a></span>findOne() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::findOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SingleRowCallback &amp;&#160;</td>
          <td class="paramname"><em>rcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionCallback &amp;&#160;</td>
          <td class="paramname"><em>ecb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously find one record that matches the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
    <tr><td class="paramname">rcb</td><td>is called with the result. </td></tr>
    <tr><td class="paramname">ecb</td><td>is called when an error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf1cdcb5147dcdaabd905542a3a94502" name="acf1cdcb5147dcdaabd905542a3a94502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1cdcb5147dcdaabd905542a3a94502">&#9670;&#160;</a></span>forUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a>&lt; T &gt; &amp; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::forUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the result for updating. </p>
<dl class="section return"><dt>Returns</dt><dd>Mapper&lt;T&gt;&amp; The <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> itself. </dd></dl>

</div>
</div>
<a id="a4b3b1365474a612ad9e3a80b572d370c" name="a4b3b1365474a612ad9e3a80b572d370c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3b1365474a612ad9e3a80b572d370c">&#9670;&#160;</a></span>increment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Arguments&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::increment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>colNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountCallback &amp;&#160;</td>
          <td class="paramname"><em>rcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionCallback &amp;&#160;</td>
          <td class="paramname"><em>ecb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arguments...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously update some records that match the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colNames</td><td>Columns to increment. </td></tr>
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
    <tr><td class="paramname">rcb</td><td>is called with the result. </td></tr>
    <tr><td class="paramname">ecb</td><td>is called when an error occurs. </td></tr>
    <tr><td class="paramname">args</td><td>Specify the amount by which the columns should be incremented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaef5041bc5c5beb57b5a109df325c2c2" name="aaef5041bc5c5beb57b5a109df325c2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef5041bc5c5beb57b5a109df325c2c2">&#9670;&#160;</a></span>increment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Arguments&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::increment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>colNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arguments...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update some records that match the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colNames</td><td>Columns to increment. </td></tr>
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
    <tr><td class="paramname">args</td><td>Specify the amount by which the columns should be incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of updated records. </dd></dl>

</div>
</div>
<a id="a706da16824423bc9bcafb3c7458af5c8" name="a706da16824423bc9bcafb3c7458af5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706da16824423bc9bcafb3c7458af5c8">&#9670;&#160;</a></span>incrementFuture()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Arguments&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; size_t &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::incrementFuture </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>colNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arguments...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously update some records that match the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colNames</td><td>Columns to increment. </td></tr>
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
    <tr><td class="paramname">args</td><td>Specify the amount by which the columns should be incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::future&lt;size_t&gt; The future object with which user can get the number of updated records. </dd></dl>

</div>
</div>
<a id="a0bbf6f927e24ae0374c587e3a0b5cad9" name="a0bbf6f927e24ae0374c587e3a0b5cad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbf6f927e24ae0374c587e3a0b5cad9">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SingleRowCallback &amp;&#160;</td>
          <td class="paramname"><em>rcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionCallback &amp;&#160;</td>
          <td class="paramname"><em>ecb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously insert a row into the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to be inserted. </td></tr>
    <tr><td class="paramname">rcb</td><td>is called with the result (with the auto-increased primary key (if it exists)). </td></tr>
    <tr><td class="paramname">ecb</td><td>is called when an error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc1f913673dac9c1588379bea7ea82e2" name="acc1f913673dac9c1588379bea7ea82e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1f913673dac9c1588379bea7ea82e2">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a row into the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The auto-increased primary key (if it exists) is set to the obj argument after the method returns. </dd></dl>

</div>
</div>
<a id="ae5617f2634c50b0debe2f0ef6f0f9e4b" name="ae5617f2634c50b0debe2f0ef6f0f9e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5617f2634c50b0debe2f0ef6f0f9e4b">&#9670;&#160;</a></span>insertFuture()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; T &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::insertFuture </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously insert a row into the table. </p>
<dl class="section return"><dt>Returns</dt><dd>std::future&lt;T&gt; The future object with which user can get the result (with the auto-increased primary key (if it exists)). </dd></dl>

</div>
</div>
<a id="a544796659f58a3e57c11d2eda991e390" name="a544796659f58a3e57c11d2eda991e390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544796659f58a3e57c11d2eda991e390">&#9670;&#160;</a></span>limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a>&lt; T &gt; &amp; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::limit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a limit to the query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The limit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mapper&lt;T&gt;&amp; The <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> itself. </dd></dl>

</div>
</div>
<a id="a4c99d4587730c3fcd2cc7f53a1467235" name="a4c99d4587730c3fcd2cc7f53a1467235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c99d4587730c3fcd2cc7f53a1467235">&#9670;&#160;</a></span>offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a>&lt; T &gt; &amp; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::offset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a offset to the query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mapper&lt;T&gt;&amp; The <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> itself. </dd></dl>

</div>
</div>
<a id="a795acb15aaf4d3aa2023daaa8496d988" name="a795acb15aaf4d3aa2023daaa8496d988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795acb15aaf4d3aa2023daaa8496d988">&#9670;&#160;</a></span>orderBy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a>&lt; T &gt; &amp; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::orderBy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SortOrder &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>SortOrder::ASC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the order of the results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colName</td><td>the column name, the results are sorted by that column </td></tr>
    <tr><td class="paramname">order</td><td>Ascending or descending order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mapper&lt;T&gt;&amp; The <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> itself. </dd></dl>

</div>
</div>
<a id="af25ed6fb2a95a42260817a9572e0af13" name="af25ed6fb2a95a42260817a9572e0af13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25ed6fb2a95a42260817a9572e0af13">&#9670;&#160;</a></span>orderBy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a>&lt; T &gt; &amp; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::orderBy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>colIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SortOrder &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>SortOrder::ASC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the order of the results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colIndex</td><td>the column index, the results are sorted by that column </td></tr>
    <tr><td class="paramname">order</td><td>Ascending or descending order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mapper&lt;T&gt;&amp; The <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> itself. </dd></dl>

</div>
</div>
<a id="a30ffad65a6033ac542abe62385fdb2bd" name="a30ffad65a6033ac542abe62385fdb2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ffad65a6033ac542abe62385fdb2bd">&#9670;&#160;</a></span>paginate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrogon_1_1orm_1_1_mapper.html">Mapper</a>&lt; T &gt; &amp; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::paginate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>perPage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set limit and offset to achieve pagination. This method will override <a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a544796659f58a3e57c11d2eda991e390" title="Add a limit to the query.">limit()</a> and <a class="el" href="classdrogon_1_1orm_1_1_mapper.html#a4c99d4587730c3fcd2cc7f53a1467235" title="Add a offset to the query.">offset()</a>, and will be overridden by them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>The page number </td></tr>
    <tr><td class="paramname">perPage</td><td>The number of columns per page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mapper&lt;T&gt;&amp; The <a class="el" href="classdrogon_1_1orm_1_1_mapper.html" title="The mapper template.">Mapper</a> itself. </dd></dl>

</div>
</div>
<a id="ac790a8de5878ad032c70a4df30a814db" name="ac790a8de5878ad032c70a4df30a814db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac790a8de5878ad032c70a4df30a814db">&#9670;&#160;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The record. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of updated records. It only could be 0 or 1. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The table must have a primary key. </dd></dl>

</div>
</div>
<a id="aab7c8260a6d27b46fde938a46b8d80b2" name="aab7c8260a6d27b46fde938a46b8d80b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7c8260a6d27b46fde938a46b8d80b2">&#9670;&#160;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountCallback &amp;&#160;</td>
          <td class="paramname"><em>rcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionCallback &amp;&#160;</td>
          <td class="paramname"><em>ecb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously update a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The record. </td></tr>
    <tr><td class="paramname">rcb</td><td>is called with the number of updated records. </td></tr>
    <tr><td class="paramname">ecb</td><td>is called when an error occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The table must have a primary key. </dd></dl>

</div>
</div>
<a id="aad91269d6ceb377cee126c2aafb7d03f" name="aad91269d6ceb377cee126c2aafb7d03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad91269d6ceb377cee126c2aafb7d03f">&#9670;&#160;</a></span>updateBy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Arguments&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::updateBy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>colNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountCallback &amp;&#160;</td>
          <td class="paramname"><em>rcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExceptionCallback &amp;&#160;</td>
          <td class="paramname"><em>ecb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arguments &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously select the rows that match both the primary key and the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colNames</td><td>Columns to update. </td></tr>
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
    <tr><td class="paramname">rcb</td><td>is called with the result. </td></tr>
    <tr><td class="paramname">ecb</td><td>is called when an error occurs. </td></tr>
    <tr><td class="paramname">args</td><td>New value of target columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4447263f366c14b4f2a22f3c386620f3" name="a4447263f366c14b4f2a22f3c386620f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4447263f366c14b4f2a22f3c386620f3">&#9670;&#160;</a></span>updateBy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Arguments&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::updateBy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>colNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arguments &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a record that match both the primary key and the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colNames</td><td>Columns to update. </td></tr>
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
    <tr><td class="paramname">args</td><td>New value of target columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of updated records. It only could be 0 or 1. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The table must have a primary key. </dd></dl>

</div>
</div>
<a id="a8f9001de14c59a917e42c4a1bbb57a7b" name="a8f9001de14c59a917e42c4a1bbb57a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9001de14c59a917e42c4a1bbb57a7b">&#9670;&#160;</a></span>updateFuture()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; size_t &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::updateFuture </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously update a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The record. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::future&lt;size_t&gt; The future object with which user can get the number of updated records. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The table must have a primary key. </dd></dl>

</div>
</div>
<a id="acb2d7d47e0903c8c84e2f9115be54e38" name="acb2d7d47e0903c8c84e2f9115be54e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2d7d47e0903c8c84e2f9115be54e38">&#9670;&#160;</a></span>updateFutureBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Arguments&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; size_t &gt; <a class="el" href="classdrogon_1_1orm_1_1_mapper.html">drogon::orm::Mapper</a>&lt; T &gt;::updateFutureBy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>colNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1orm_1_1_criteria.html">Criteria</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arguments &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously update a record that match both the primary key and the given criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colNames</td><td>Columns to update. </td></tr>
    <tr><td class="paramname">criteria</td><td>The criteria. </td></tr>
    <tr><td class="paramname">args</td><td>New value of target columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::future&lt;size_t&gt; The future object with which user can get the number of updated records. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The table must have a primary key. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>orm_lib/inc/drogon/orm/<a class="el" href="_mapper_8h_source.html">Mapper.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>

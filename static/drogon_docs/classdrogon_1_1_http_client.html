<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drogon: drogon::HttpClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drogon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedrogon.html">drogon</a></li><li class="navelem"><a class="el" href="classdrogon_1_1_http_client.html">HttpClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classdrogon_1_1_http_client-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">drogon::HttpClient Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Asynchronous http client.  
 <a href="classdrogon_1_1_http_client.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_http_client_8h_source.html">HttpClient.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for drogon::HttpClient:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classdrogon_1_1_http_client.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a75a3a447835761796fd1518bbd60a552" id="r_a75a3a447835761796fd1518bbd60a552"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#a75a3a447835761796fd1518bbd60a552">sendRequest</a> (const HttpRequestPtr &amp;req, const HttpReqCallback &amp;callback, double timeout=0)=0</td></tr>
<tr class="memdesc:a75a3a447835761796fd1518bbd60a552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a request asynchronously to the server.  <br /></td></tr>
<tr class="separator:a75a3a447835761796fd1518bbd60a552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baf533123ff6b3f5e855fb0922a4fb4" id="r_a2baf533123ff6b3f5e855fb0922a4fb4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#a2baf533123ff6b3f5e855fb0922a4fb4">sendRequest</a> (const HttpRequestPtr &amp;req, HttpReqCallback &amp;&amp;callback, double timeout=0)=0</td></tr>
<tr class="memdesc:a2baf533123ff6b3f5e855fb0922a4fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a request asynchronously to the server.  <br /></td></tr>
<tr class="separator:a2baf533123ff6b3f5e855fb0922a4fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9851520c2f52037200182dd1248cce72" id="r_a9851520c2f52037200182dd1248cce72"><td class="memItemLeft" align="right" valign="top">std::pair&lt; ReqResult, HttpResponsePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#a9851520c2f52037200182dd1248cce72">sendRequest</a> (const HttpRequestPtr &amp;req, double timeout=0)</td></tr>
<tr class="memdesc:a9851520c2f52037200182dd1248cce72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a request synchronously to the server and return the response.  <br /></td></tr>
<tr class="separator:a9851520c2f52037200182dd1248cce72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c46086acc82d09ef48c6df07415387c" id="r_a1c46086acc82d09ef48c6df07415387c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#a1c46086acc82d09ef48c6df07415387c">setSockOptCallback</a> (std::function&lt; void(int)&gt; cb)=0</td></tr>
<tr class="memdesc:a1c46086acc82d09ef48c6df07415387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket options(before connecting)  <br /></td></tr>
<tr class="separator:a1c46086acc82d09ef48c6df07415387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed28e7469e6b46e386b705a8be5a596d" id="r_aed28e7469e6b46e386b705a8be5a596d"><td class="memItemLeft" align="right" valign="top"><a id="aed28e7469e6b46e386b705a8be5a596d" name="aed28e7469e6b46e386b705a8be5a596d"></a>
virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>requestsBufferSize</b> ()=0</td></tr>
<tr class="memdesc:aed28e7469e6b46e386b705a8be5a596d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of unsent http requests in the current http client cache buffer. <br /></td></tr>
<tr class="separator:aed28e7469e6b46e386b705a8be5a596d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf56c787b4788d70b7cedc22a8454be" id="r_acaf56c787b4788d70b7cedc22a8454be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#acaf56c787b4788d70b7cedc22a8454be">setPipeliningDepth</a> (size_t depth)=0</td></tr>
<tr class="separator:acaf56c787b4788d70b7cedc22a8454be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff0c2aee10ba12ee4273c1c70a517a2" id="r_abff0c2aee10ba12ee4273c1c70a517a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#abff0c2aee10ba12ee4273c1c70a517a2">enableCookies</a> (bool flag=true)=0</td></tr>
<tr class="memdesc:abff0c2aee10ba12ee4273c1c70a517a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable cookies for the client.  <br /></td></tr>
<tr class="separator:abff0c2aee10ba12ee4273c1c70a517a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659e5409827e4871c8c799e378c36b5b" id="r_a659e5409827e4871c8c799e378c36b5b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#a659e5409827e4871c8c799e378c36b5b">addCookie</a> (const std::string &amp;key, const std::string &amp;value)=0</td></tr>
<tr class="memdesc:a659e5409827e4871c8c799e378c36b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a cookie to the client.  <br /></td></tr>
<tr class="separator:a659e5409827e4871c8c799e378c36b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56a5fdcda993f22c19afd7de69cb4b6" id="r_ab56a5fdcda993f22c19afd7de69cb4b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#ab56a5fdcda993f22c19afd7de69cb4b6">addCookie</a> (const <a class="el" href="classdrogon_1_1_cookie.html">Cookie</a> &amp;cookie)=0</td></tr>
<tr class="memdesc:ab56a5fdcda993f22c19afd7de69cb4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a cookie to the client.  <br /></td></tr>
<tr class="separator:ab56a5fdcda993f22c19afd7de69cb4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6600e618e9d2c1a14923e2b593c6ca06" id="r_a6600e618e9d2c1a14923e2b593c6ca06"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#a6600e618e9d2c1a14923e2b593c6ca06">setUserAgent</a> (const std::string &amp;userAgent)=0</td></tr>
<tr class="memdesc:a6600e618e9d2c1a14923e2b593c6ca06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the user_agent header, the default value is 'DrogonClient' if this method is not used.  <br /></td></tr>
<tr class="separator:a6600e618e9d2c1a14923e2b593c6ca06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46938d38324232591ade062a91fcb106" id="r_a46938d38324232591ade062a91fcb106"><td class="memItemLeft" align="right" valign="top"><a id="a46938d38324232591ade062a91fcb106" name="a46938d38324232591ade062a91fcb106"></a>
virtual trantor::EventLoop *&#160;</td><td class="memItemRight" valign="bottom"><b>getLoop</b> ()=0</td></tr>
<tr class="memdesc:a46938d38324232591ade062a91fcb106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event loop of the client;. <br /></td></tr>
<tr class="separator:a46938d38324232591ade062a91fcb106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d924c406509050d2b05e43c627ba50" id="r_a86d924c406509050d2b05e43c627ba50"><td class="memItemLeft" align="right" valign="top"><a id="a86d924c406509050d2b05e43c627ba50" name="a86d924c406509050d2b05e43c627ba50"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>bytesSent</b> () const =0</td></tr>
<tr class="memdesc:a86d924c406509050d2b05e43c627ba50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes sent or received. <br /></td></tr>
<tr class="separator:a86d924c406509050d2b05e43c627ba50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7267c9991f97dc6384735dd3559db4" id="r_abb7267c9991f97dc6384735dd3559db4"><td class="memItemLeft" align="right" valign="top"><a id="abb7267c9991f97dc6384735dd3559db4" name="abb7267c9991f97dc6384735dd3559db4"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>bytesReceived</b> () const =0</td></tr>
<tr class="separator:abb7267c9991f97dc6384735dd3559db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cdd645ffe4e3778a1ef9a46d1e9f2e" id="r_ae5cdd645ffe4e3778a1ef9a46d1e9f2e"><td class="memItemLeft" align="right" valign="top"><a id="ae5cdd645ffe4e3778a1ef9a46d1e9f2e" name="ae5cdd645ffe4e3778a1ef9a46d1e9f2e"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>host</b> () const =0</td></tr>
<tr class="separator:ae5cdd645ffe4e3778a1ef9a46d1e9f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f0e988b577a833788aac89c0f7e7ac" id="r_a26f0e988b577a833788aac89c0f7e7ac"><td class="memItemLeft" align="right" valign="top"><a id="a26f0e988b577a833788aac89c0f7e7ac" name="a26f0e988b577a833788aac89c0f7e7ac"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getHost</b> () const</td></tr>
<tr class="separator:a26f0e988b577a833788aac89c0f7e7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e0eef4b4ac55056db5d50fbb28afe3" id="r_ac9e0eef4b4ac55056db5d50fbb28afe3"><td class="memItemLeft" align="right" valign="top"><a id="ac9e0eef4b4ac55056db5d50fbb28afe3" name="ac9e0eef4b4ac55056db5d50fbb28afe3"></a>
virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>port</b> () const =0</td></tr>
<tr class="separator:ac9e0eef4b4ac55056db5d50fbb28afe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870c638d55f61417478cece8e72772c5" id="r_a870c638d55f61417478cece8e72772c5"><td class="memItemLeft" align="right" valign="top"><a id="a870c638d55f61417478cece8e72772c5" name="a870c638d55f61417478cece8e72772c5"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>getPort</b> () const</td></tr>
<tr class="separator:a870c638d55f61417478cece8e72772c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2245c812ff28a53fefb14b5bebecb37" id="r_ad2245c812ff28a53fefb14b5bebecb37"><td class="memItemLeft" align="right" valign="top"><a id="ad2245c812ff28a53fefb14b5bebecb37" name="ad2245c812ff28a53fefb14b5bebecb37"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>secure</b> () const =0</td></tr>
<tr class="separator:ad2245c812ff28a53fefb14b5bebecb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553ff50cd727f1f4cde70b60658e4a51" id="r_a553ff50cd727f1f4cde70b60658e4a51"><td class="memItemLeft" align="right" valign="top"><a id="a553ff50cd727f1f4cde70b60658e4a51" name="a553ff50cd727f1f4cde70b60658e4a51"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>onDefaultPort</b> () const</td></tr>
<tr class="separator:a553ff50cd727f1f4cde70b60658e4a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9337df0670830e4e2a15115fb735bd" id="r_aab9337df0670830e4e2a15115fb735bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#aab9337df0670830e4e2a15115fb735bd">setCertPath</a> (const std::string &amp;cert, const std::string &amp;key)=0</td></tr>
<tr class="memdesc:aab9337df0670830e4e2a15115fb735bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the client certificate used by the HTTP connection.  <br /></td></tr>
<tr class="separator:aab9337df0670830e4e2a15115fb735bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39a98a270b9ce5ca1e4b86609f33039" id="r_ae39a98a270b9ce5ca1e4b86609f33039"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#ae39a98a270b9ce5ca1e4b86609f33039">addSSLConfigs</a> (const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;sslConfCmds)=0</td></tr>
<tr class="memdesc:ae39a98a270b9ce5ca1e4b86609f33039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies command style options for <code>SSL_CONF_cmd</code>  <br /></td></tr>
<tr class="separator:ae39a98a270b9ce5ca1e4b86609f33039"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7296d596c71819dd5397cff40f20aca0" id="r_a7296d596c71819dd5397cff40f20aca0"><td class="memItemLeft" align="right" valign="top">static HttpClientPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#a7296d596c71819dd5397cff40f20aca0">newHttpClient</a> (const std::string &amp;ip, uint16_t port, bool useSSL=false, trantor::EventLoop *loop=nullptr, bool useOldTLS=false, bool validateCert=true)</td></tr>
<tr class="memdesc:a7296d596c71819dd5397cff40f20aca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new HTTP client which use ip and port to connect to server.  <br /></td></tr>
<tr class="separator:a7296d596c71819dd5397cff40f20aca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a0463f7e09734553df1c4af137c9d1" id="r_a12a0463f7e09734553df1c4af137c9d1"><td class="memItemLeft" align="right" valign="top">static HttpClientPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrogon_1_1_http_client.html#a12a0463f7e09734553df1c4af137c9d1">newHttpClient</a> (const std::string &amp;hostString, trantor::EventLoop *loop=nullptr, bool useOldTLS=false, bool validateCert=true)</td></tr>
<tr class="memdesc:a12a0463f7e09734553df1c4af137c9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Http client using the hostString to connect to server.  <br /></td></tr>
<tr class="separator:a12a0463f7e09734553df1c4af137c9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Asynchronous http client. </p>
<p><a class="el" href="classdrogon_1_1_http_client.html" title="Asynchronous http client.">HttpClient</a> implementation object uses the <a class="el" href="classdrogon_1_1_http_app_framework.html">HttpAppFramework</a>'s event loop by default, so you should call <a class="el" href="namespacedrogon.html#a0be61eeb45a4c229be4041cd60d0d906" title="A wrapper of the instance() method.">app()</a>.run() to make the client work. Each <a class="el" href="classdrogon_1_1_http_client.html" title="Asynchronous http client.">HttpClient</a> object establishes a persistent connection with the server. If the connection is broken, the client attempts to reconnect when calling the sendRequest method.</p>
<p>Using the static method newHttpClient(...) to get shared_ptr of the object implementing the class, the shared_ptr is retained in the framework until all response callbacks are invoked without fear of accidental deconstruction. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab56a5fdcda993f22c19afd7de69cb4b6" name="ab56a5fdcda993f22c19afd7de69cb4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56a5fdcda993f22c19afd7de69cb4b6">&#9670;&#160;</a></span>addCookie() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drogon::HttpClient::addCookie </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrogon_1_1_cookie.html">Cookie</a> &amp;&#160;</td>
          <td class="paramname"><em>cookie</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a cookie to the client. </p>
<dl class="section note"><dt>Note</dt><dd>These methods are independent of the <a class="el" href="classdrogon_1_1_http_client.html#abff0c2aee10ba12ee4273c1c70a517a2" title="Enable cookies for the client.">enableCookies()</a> method. Whether the <a class="el" href="classdrogon_1_1_http_client.html#abff0c2aee10ba12ee4273c1c70a517a2" title="Enable cookies for the client.">enableCookies()</a> is called with true or false, the cookies added by these methods will be sent to the server. </dd></dl>

</div>
</div>
<a id="a659e5409827e4871c8c799e378c36b5b" name="a659e5409827e4871c8c799e378c36b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659e5409827e4871c8c799e378c36b5b">&#9670;&#160;</a></span>addCookie() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drogon::HttpClient::addCookie </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a cookie to the client. </p>
<dl class="section note"><dt>Note</dt><dd>These methods are independent of the <a class="el" href="classdrogon_1_1_http_client.html#abff0c2aee10ba12ee4273c1c70a517a2" title="Enable cookies for the client.">enableCookies()</a> method. Whether the <a class="el" href="classdrogon_1_1_http_client.html#abff0c2aee10ba12ee4273c1c70a517a2" title="Enable cookies for the client.">enableCookies()</a> is called with true or false, the cookies added by these methods will be sent to the server. </dd></dl>

</div>
</div>
<a id="ae39a98a270b9ce5ca1e4b86609f33039" name="ae39a98a270b9ce5ca1e4b86609f33039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39a98a270b9ce5ca1e4b86609f33039">&#9670;&#160;</a></span>addSSLConfigs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drogon::HttpClient::addSSLConfigs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>sslConfCmds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Supplies command style options for <code>SSL_CONF_cmd</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sslConfCmds</td><td>options for SSL_CONF_cmd </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method has no effect if the HTTP client is communicating via unencrypted HTTP <div class="fragment"><div class="line"><a class="code hl_function" href="classdrogon_1_1_http_client.html#ae39a98a270b9ce5ca1e4b86609f33039">addSSLConfigs</a>({{<span class="stringliteral">&quot;-dhparam&quot;</span>, <span class="stringliteral">&quot;/path/to/dhparam&quot;</span>}, {<span class="stringliteral">&quot;-strict&quot;</span>, <span class="stringliteral">&quot;&quot;</span>}});</div>
<div class="ttc" id="aclassdrogon_1_1_http_client_html_ae39a98a270b9ce5ca1e4b86609f33039"><div class="ttname"><a href="classdrogon_1_1_http_client.html#ae39a98a270b9ce5ca1e4b86609f33039">drogon::HttpClient::addSSLConfigs</a></div><div class="ttdeci">virtual void addSSLConfigs(const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;sslConfCmds)=0</div><div class="ttdoc">Supplies command style options for SSL_CONF_cmd</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="abff0c2aee10ba12ee4273c1c70a517a2" name="abff0c2aee10ba12ee4273c1c70a517a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff0c2aee10ba12ee4273c1c70a517a2">&#9670;&#160;</a></span>enableCookies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drogon::HttpClient::enableCookies </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable cookies for the client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>if the parameter is true, all requests sent by the client carry the cookies set by the server side. Cookies are disabled by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12a0463f7e09734553df1c4af137c9d1" name="a12a0463f7e09734553df1c4af137c9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a0463f7e09734553df1c4af137c9d1">&#9670;&#160;</a></span>newHttpClient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static HttpClientPtr drogon::HttpClient::newHttpClient </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hostString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">trantor::EventLoop *&#160;</td>
          <td class="paramname"><em>loop</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useOldTLS</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>validateCert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a Http client using the hostString to connect to server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostString</td><td>this parameter must be prefixed by '<a href="http://'">http://'</a> or '<a href="https://'">https://'</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Examples for hostString: </p><div class="fragment"><div class="line">https:<span class="comment">//www.baidu.com</span></div>
<div class="line">http:<span class="comment">//www.baidu.com</span></div>
<div class="line">https:<span class="comment">//127.0.0.1:8080/</span></div>
<div class="line">http:<span class="comment">//127.0.0.1</span></div>
<div class="line">http:<span class="comment">//[::1]:8080/   //IPv6 address must be enclosed in [], rfc2732</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>If the loop parameter is set to nullptr, the client uses the <a class="el" href="classdrogon_1_1_http_app_framework.html">HttpAppFramework</a>'s event loop, otherwise it runs in the loop identified by the parameter.</td></tr>
    <tr><td class="paramname">useOldTLS</td><td>If the parameter is set to true, the TLS1.0/1.1 are enabled for HTTPS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">validateCert</td><td>If the parameter is set to true, the client validates the server certificate when SSL handshaking.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Don't add path and parameters in hostString, the request path and parameters should be set in HttpRequestPtr when calling the <a class="el" href="classdrogon_1_1_http_client.html#a75a3a447835761796fd1518bbd60a552" title="Send a request asynchronously to the server.">sendRequest()</a> method. </dd></dl>

</div>
</div>
<a id="a7296d596c71819dd5397cff40f20aca0" name="a7296d596c71819dd5397cff40f20aca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7296d596c71819dd5397cff40f20aca0">&#9670;&#160;</a></span>newHttpClient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static HttpClientPtr drogon::HttpClient::newHttpClient </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useSSL</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">trantor::EventLoop *&#160;</td>
          <td class="paramname"><em>loop</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useOldTLS</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>validateCert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new HTTP client which use ip and port to connect to server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The ip address of the HTTP server </td></tr>
    <tr><td class="paramname">port</td><td>The port of the HTTP server </td></tr>
    <tr><td class="paramname">useSSL</td><td>if the parameter is set to true, the client connects to the server using HTTPS. </td></tr>
    <tr><td class="paramname">loop</td><td>If the loop parameter is set to nullptr, the client uses the <a class="el" href="classdrogon_1_1_http_app_framework.html">HttpAppFramework</a>'s event loop, otherwise it runs in the loop identified by the parameter. </td></tr>
    <tr><td class="paramname">useOldTLS</td><td>If the parameter is set to true, the TLS1.0/1.1 are enabled for HTTPS. </td></tr>
    <tr><td class="paramname">validateCert</td><td>If the parameter is set to true, the client validates the server certificate when SSL handshaking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HttpClientPtr The smart pointer to the new client object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>: The ip parameter support for both ipv4 and ipv6 address </dd></dl>

</div>
</div>
<a id="a75a3a447835761796fd1518bbd60a552" name="a75a3a447835761796fd1518bbd60a552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a3a447835761796fd1518bbd60a552">&#9670;&#160;</a></span>sendRequest() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drogon::HttpClient::sendRequest </td>
          <td>(</td>
          <td class="paramtype">const HttpRequestPtr &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HttpReqCallback &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a request asynchronously to the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request sent to the server. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback is called when the response is received from the server. </td></tr>
    <tr><td class="paramname">timeout</td><td>In seconds. If the response is not received within the timeout, the callback is called with <code>ReqResult::Timeout</code> and an empty response. The zero value by default disables the timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The request object is altered(some headers are added to it) before it is sent, so calling this method with a same request object in different thread is dangerous. Please be careful when using timeout on an non-idempotent request. </dd></dl>

</div>
</div>
<a id="a9851520c2f52037200182dd1248cce72" name="a9851520c2f52037200182dd1248cce72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9851520c2f52037200182dd1248cce72">&#9670;&#160;</a></span>sendRequest() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; ReqResult, HttpResponsePtr &gt; drogon::HttpClient::sendRequest </td>
          <td>(</td>
          <td class="paramtype">const HttpRequestPtr &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a request synchronously to the server and return the response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td></td></tr>
    <tr><td class="paramname">timeout</td><td>In seconds. If the response is not received within the timeout, the <code>ReqResult::Timeout</code> and an empty response is returned. The zero value by default disables the timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;ReqResult, HttpResponsePtr&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Never call this function in the event loop thread of the client (partially in the callback function of the asynchronous sendRequest method), otherwise the thread will be blocked forever. Please be careful when using timeout on an non-idempotent request. </dd></dl>

</div>
</div>
<a id="a2baf533123ff6b3f5e855fb0922a4fb4" name="a2baf533123ff6b3f5e855fb0922a4fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2baf533123ff6b3f5e855fb0922a4fb4">&#9670;&#160;</a></span>sendRequest() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drogon::HttpClient::sendRequest </td>
          <td>(</td>
          <td class="paramtype">const HttpRequestPtr &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HttpReqCallback &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a request asynchronously to the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request sent to the server. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback is called when the response is received from the server. </td></tr>
    <tr><td class="paramname">timeout</td><td>In seconds. If the response is not received within the timeout, the callback is called with <code>ReqResult::Timeout</code> and an empty response. The zero value by default disables the timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The request object is altered(some headers are added to it) before it is sent, so calling this method with a same request object in different thread is dangerous. Please be careful when using timeout on an non-idempotent request. </dd></dl>

</div>
</div>
<a id="aab9337df0670830e4e2a15115fb735bd" name="aab9337df0670830e4e2a15115fb735bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9337df0670830e4e2a15115fb735bd">&#9670;&#160;</a></span>setCertPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drogon::HttpClient::setCertPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the client certificate used by the HTTP connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>Path to the certificate </td></tr>
    <tr><td class="paramname">key</td><td>Path to the certificate's private key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method has no effect if the HTTP client is communicating via unencrypted HTTP </dd></dl>

</div>
</div>
<a id="acaf56c787b4788d70b7cedc22a8454be" name="acaf56c787b4788d70b7cedc22a8454be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf56c787b4788d70b7cedc22a8454be">&#9670;&#160;</a></span>setPipeliningDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drogon::HttpClient::setPipeliningDepth </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the pipelining depth, which is the number of requests that are not responding. If this method is not called, the default depth value is 0 which means the pipelining is disabled. For details about pipelining, see rfc2616-8.1.2.2 </p>

</div>
</div>
<a id="a1c46086acc82d09ef48c6df07415387c" name="a1c46086acc82d09ef48c6df07415387c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c46086acc82d09ef48c6df07415387c">&#9670;&#160;</a></span>setSockOptCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drogon::HttpClient::setSockOptCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(int)&gt;&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set socket options(before connecting) </p>
<p>Set the callback which is called before connecting to the server. The callback is used to set socket options on the socket fd.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> client = <a class="code hl_function" href="classdrogon_1_1_http_client.html#a7296d596c71819dd5397cff40f20aca0">HttpClient::newHttpClient</a>(<span class="stringliteral">&quot;http://www.baidu.com&quot;</span>);</div>
<div class="line">client-&gt;setSockOptCallback([](<span class="keywordtype">int</span> fd) {});</div>
<div class="line"><span class="keyword">auto</span> req = <a class="code hl_function" href="classdrogon_1_1_http_request.html#a4ce310707acce8c34bbc60cb217acd28">HttpRequest::newHttpRequest</a>();</div>
<div class="line">client-&gt;sendRequest(req, [](ReqResult result, <span class="keyword">const</span> HttpResponsePtr&amp;</div>
<div class="line">response) {});</div>
<div class="ttc" id="aclassdrogon_1_1_http_client_html_a7296d596c71819dd5397cff40f20aca0"><div class="ttname"><a href="classdrogon_1_1_http_client.html#a7296d596c71819dd5397cff40f20aca0">drogon::HttpClient::newHttpClient</a></div><div class="ttdeci">static HttpClientPtr newHttpClient(const std::string &amp;ip, uint16_t port, bool useSSL=false, trantor::EventLoop *loop=nullptr, bool useOldTLS=false, bool validateCert=true)</div><div class="ttdoc">Create a new HTTP client which use ip and port to connect to server.</div></div>
<div class="ttc" id="aclassdrogon_1_1_http_request_html_a4ce310707acce8c34bbc60cb217acd28"><div class="ttname"><a href="classdrogon_1_1_http_request.html#a4ce310707acce8c34bbc60cb217acd28">drogon::HttpRequest::newHttpRequest</a></div><div class="ttdeci">static HttpRequestPtr newHttpRequest()</div><div class="ttdoc">Create a normal request with http method Get and version Http1.1.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6600e618e9d2c1a14923e2b593c6ca06" name="a6600e618e9d2c1a14923e2b593c6ca06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6600e618e9d2c1a14923e2b593c6ca06">&#9670;&#160;</a></span>setUserAgent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drogon::HttpClient::setUserAgent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>userAgent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the user_agent header, the default value is 'DrogonClient' if this method is not used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userAgent</td><td>The user_agent value, if it is empty, the user_agent header is not sent to the server. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lib/inc/drogon/<a class="el" href="_http_client_8h_source.html">HttpClient.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
